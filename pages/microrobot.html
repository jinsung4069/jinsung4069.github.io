<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë§ˆì´í¬ë¡œ ë¡œë´‡ - ì›¹ ë²„ì „</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #07090d;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // === ìƒ‰ìƒ ë° ìœ í‹¸ ===
        const COLOR_NAMES = ["blue", "yellow", "green", "red", "pink", "white"];
        const KOREAN_LABELS = {
          blue: "íŒŒë‘",
          yellow: "ë…¸ë‘",
          green: "ì´ˆë¡",
          red: "ë¹¨ê°•",
          pink: "ë¶„í™",
          white: "í°ìƒ‰",
        };
        const COLOR_HEX = {
          blue: "#3498db",
          yellow: "#f1c40f",
          green: "#2ecc71",
          red: "#e74c3c",
          pink: "#e84393",
          white: "#ecf0f1",
        };

        function textColorFor(bg) {
          if (bg === "#f1c40f" || bg === "#ecf0f1") return "#111";
          return "#fff";
        }

        // ë³´ë“œ êµ¬ì¡°: 6x6, ê° ìˆ«ì(1~6) 6íšŒ, ê° ìƒ‰ìƒ 6íšŒ, (num,color) ìŒì€ ì •í™•íˆ 1íšŒì”© ë“±ì¥
        function buildNumbersLayout() {
          // ê° ìˆ«ìê°€ ì •í™•íˆ 6íšŒ ë“±ì¥í•˜ë„ë¡ ë§Œë“œëŠ” íŒ¨í„´ (í–‰ë§ˆë‹¤ ë‘ ìˆ«ìë¥¼ 3íšŒì”© ë°°ì¹˜)
          const rows = [
            [1, 2, 1, 2, 1, 2],
            [3, 4, 3, 4, 3, 4],
            [5, 6, 5, 6, 5, 6],
            [1, 3, 1, 3, 1, 3],
            [2, 5, 2, 5, 2, 5],
            [4, 6, 4, 6, 4, 6],
          ];
          return rows;
        }

        function shuffle(arr) {
          const a = [...arr];
          for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
          }
          return a;
        }

        function buildColorsLayout(numbers) {
          // ì•„ì´ë””ì–´: ê° ìˆ«ì(1~6)ê°€ ë“±ì¥í•˜ëŠ” 6ê°œì˜ ì¢Œí‘œì— 6ê°€ì§€ ìƒ‰ìƒì„ ì •í™•íˆ í•œ ë²ˆì”© ë°°ì •
          const coordsByNum = { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] };
          for (let r = 0; r < 6; r++) {
            for (let c = 0; c < 6; c++) {
              coordsByNum[numbers[r][c]].push({ r, c });
            }
          }
          const colors = Array.from({ length: 6 }, () => Array(6).fill("white"));
          for (let n = 1; n <= 6; n++) {
            const order = shuffle([...COLOR_NAMES]);
            const spots = coordsByNum[n];
            for (let i = 0; i < 6; i++) {
              const { r, c } = spots[i];
              colors[r][c] = order[i];
            }
          }
          return colors;
        }

        function buildBoard() {
          const numbers = buildNumbersLayout();
          const colors = buildColorsLayout(numbers);
          return Array.from({ length: 6 }, (_, r) =>
            Array.from({ length: 6 }, (_, c) => ({ r, c, num: numbers[r][c], color: colors[r][c] }))
          );
        }

        // ì¸ì ‘(ì´ë™ ê°€ëŠ¥) ì •ì  ê³„ì‚°: ê°™ì€ í–‰/ì—´ & (ëŒ€ìƒ.num==í˜„ì¬.num || ëŒ€ìƒ.color==í˜„ì¬.color)
        function neighbors(board, from) {
          const out = [];
          const R = from.r, C = from.c;
          // ê°™ì€ í–‰
          for (let c = 0; c < 6; c++) {
            if (c === C) continue;
            const dst = board[R][c];
            if (dst.num === from.num || dst.color === from.color) out.push(dst);
          }
          // ê°™ì€ ì—´
          for (let r = 0; r < 6; r++) {
            if (r === R) continue;
            const dst = board[r][C];
            if (dst.num === from.num || dst.color === from.color) out.push(dst);
          }
          return out;
        }

        // BFSë¡œ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
        function bfs(board, start, goal) {
          const key = (x) => `${x.r},${x.c}`;
          const q = [];
          const prev = new Map();
          q.push(start);
          prev.set(key(start), null);
          for (let qi = 0; qi < q.length; qi++) {
            const cur = q[qi];
            if (cur.r === goal.r && cur.c === goal.c) {
              // ê²½ë¡œ ë³µì›
              const path = [];
              let k = key(cur);
              while (k) {
                const [r, c] = k.split(",").map(Number);
                path.push(board[r][c]);
                k = prev.get(k) ?? null;
              }
              return path.reverse();
            }
            for (const nxt of neighbors(board, cur)) {
              const nk = key(nxt);
              if (!prev.has(nk)) {
                prev.set(nk, key(cur));
                q.push(nxt);
              }
            }
          }
          return null;
        }

        // ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°
        function rollNumber() { return Math.floor(Math.random() * 6) + 1; }
        function rollColor() { return COLOR_NAMES[Math.floor(Math.random() * 6)]; }

        // ì…€ í‚¤
        const cellKey = (r, c) => `${r}-${c}`;

        // === ì‹œê° êµ¬ì„±(ì˜ìƒ ìŠ¤íƒ€ì¼) ===
        const PIP_LAYOUT = {
          1: [[1,1]],
          2: [[0,0],[2,2]],
          3: [[0,0],[1,1],[2,2]],
          4: [[0,0],[0,2],[2,0],[2,2]],
          5: [[0,0],[0,2],[1,1],[2,0],[2,2]],
          6: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,2]],
        };

        function PipTile({num, color}) {
          // ì£¼ì‚¬ìœ„ ê°™ì€ ì›í˜• ëˆˆê¸ˆ
          const pipColor = COLOR_HEX[color];
          const cells = Array.from({length:9}, (_,i)=>({r:Math.floor(i/3), c:i%3}));
          const on = new Set(PIP_LAYOUT[num].map(([r,c])=>`${r}-${c}`));
          return (
            <div className="grid grid-cols-3 grid-rows-3 w-full h-full p-2 gap-1">
              {cells.map(({r,c})=>{
                const active = on.has(`${r}-${c}`);
                return (
                  <div key={`${r}-${c}`} className="rounded-full" style={{
                    background: active? pipColor: "#0c0f14",
                    boxShadow: active? `0 0 8px ${pipColor}`: undefined,
                    border: active? "1px solid rgba(255,255,255,0.25)":"1px solid rgba(255,255,255,0.06)",
                  }}/>
                );
              })}
            </div>
          );
        }

        // íˆ¬ëª… ë¡œë´‡ ë§(ê¸€ë˜ìŠ¤ ëŠë‚Œ)
        function PawnGlass({size=32}){
          return (
            <svg width={size} height={size} viewBox="0 0 64 64" aria-label="robot pawn">
              <defs>
                <radialGradient id="g" cx="50%" cy="30%" r="70%">
                  <stop offset="0%" stopColor="rgba(255,255,255,0.95)"/>
                  <stop offset="60%" stopColor="rgba(255,255,255,0.55)"/>
                  <stop offset="100%" stopColor="rgba(255,255,255,0.25)"/>
                </radialGradient>
              </defs>
              <circle cx="32" cy="18" r="10" fill="url(#g)" stroke="rgba(255,255,255,0.9)"/>
              <path d="M16 50c0-9 7-16 16-16s16 7 16 16v4H16v-4z" fill="url(#g)" stroke="rgba(255,255,255,0.85)"/>
              <rect x="14" y="50" width="36" height="6" rx="3" fill="rgba(255,255,255,0.35)" stroke="rgba(255,255,255,0.7)"/>
            </svg>
          );
        }

        // ìŠ¹ì ì¹©(ì½”ì¸)
        function Coin({filled=false, size=18}){
          return (
            <svg width={size} height={size} viewBox="0 0 40 40" aria-label={filled?"coin":"empty-coin"}>
              <defs>
                <radialGradient id="cg" cx="50%" cy="35%" r="60%">
                  <stop offset="0%" stopColor="#fff59d"/>
                  <stop offset="60%" stopColor="#f4d03f"/>
                  <stop offset="100%" stopColor="#d4ac0d"/>
                </radialGradient>
              </defs>
              <circle cx="20" cy="20" r="17" fill={filled?"url(#cg)":"transparent"} stroke="#e1c16e" strokeWidth="3"/>
            </svg>
          );
        }

        // === (ê°„ë‹¨) ìì²´ í…ŒìŠ¤íŠ¸ ===
        function runSelfTests(board) {
          // 1) (num,color) ì¡°í•© ìœ ì¼ì„±
          const keys = new Set();
          board.flat().forEach((c)=>{
            const k = `${c.num}-${c.color}`;
            console.assert(!keys.has(k), "ì¤‘ë³µ ì¡°í•© ë°œê²¬", k);
            keys.add(k);
          });
          console.assert(keys.size === 36, "ì¡°í•© ê°œìˆ˜ëŠ” 36ì´ì–´ì•¼ í•¨", keys.size);
          // 2) ìˆ«ì/ìƒ‰ ê°ê° 6íšŒì”©
          const numCount = {1:0,2:0,3:0,4:0,5:0,6:0};
          const colCount = {blue:0,yellow:0,green:0,red:0,pink:0,white:0};
          board.flat().forEach(c=>{ numCount[c.num]++; colCount[c.color]++; });
          for (let n=1;n<=6;n++) console.assert(numCount[n]===6, `ìˆ«ì${n} ê°œìˆ˜=6`, numCount[n]);
          for (const k of COLOR_NAMES) console.assert(colCount[k]===6, `ìƒ‰ìƒ ${k} ê°œìˆ˜=6`, colCount[k]);
        }

        // ì»´í¬ë„ŒíŠ¸ ì‹œì‘
        function App() {
          const [board, setBoard] = useState(() => buildBoard());
          const flat = board.flat();

          // ì‹œì‘/ëª©í‘œ/ì¤‘ê°„ëª©í‘œ(ì „ë¬¸ê°€ ëª¨ë“œ)
          const [start, setStart] = useState(null);
          const [target, setTarget] = useState(null);
          const [mid, setMid] = useState(null);
          const [expert, setExpert] = useState(false);
          const [showLabels, setShowLabels] = useState(false);
          const [score, setScore] = useState(0);
          const [claimed, setClaimed] = useState(false);
          const [win, setWin] = useState(false);

          // í”Œë ˆì´ ê²½ë¡œ
          const [path, setPath] = useState([]);
          const current = path.length ? path[path.length - 1] : start;

          const [par, setPar] = useState(null);
          const [parPath, setParPath] = useState(null);
          const [reseed, setReseed] = useState(0);

          // ìƒˆ ë³´ë“œ
          function reshuffleBoard() {
            const b = buildBoard();
            setBoard(b);
            setStart(null); setTarget(null); setMid(null);
            setPath([]); setPar(null); setParPath(null);
            setClaimed(false); setWin(false);
            setReseed((x) => x + 1);
            // í…ŒìŠ¤íŠ¸
            runSelfTests(b);
          }

          // íŠ¹ì • (num,color) ì¡°í•©ì˜ ì¢Œí‘œ ì°¾ê¸°
          function cellBy(num, color) {
            const found = flat.find((c) => c.num === num && c.color === color);
            if (!found) throw new Error("í•´ë‹¹ ì¡°í•©ì„ ë³´ë“œì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return found;
          }

          // ë¼ìš´ë“œ ìƒì„± (ì‹œì‘/ëª©í‘œ/ì¤‘ê°„ëª©í‘œ)
          function newRound() {
            let s, t, m = null;
            s = cellBy(rollNumber(), rollColor());
            do { t = cellBy(rollNumber(), rollColor()); } while (t.r === s.r && t.c === s.c);
            if (expert) {
              do { m = cellBy(rollNumber(), rollColor()); } while ((m.r === s.r && m.c === s.c) || (m.r === t.r && t.c === t.c));
            }
            setStart(s); setTarget(t); setMid(m);
            setPath([s]);
            setClaimed(false);
          }

          // ì´ë™ ì‹œ ê²€ì¦
          function canMove(from, to) {
            if (!from) return false;
            if (from.r !== to.r && from.c !== to.c) return false; // ìˆ˜í‰/ìˆ˜ì§ë§Œ
            if (!(from.num === to.num || from.color === to.color)) return false; // ìˆ«ì ë˜ëŠ” ìƒ‰ ì¼ì¹˜
            if (path.find((p) => p.r === to.r && p.c === to.c)) return false; // ê°™ì€ ì¹¸ ì¬ë°©ë¬¸ ë°©ì§€(ì„ íƒ ì‚¬í•­)
            return true;
          }

          function onCellClick(dst) {
            const from = current;
            if (!from) return;
            if (!canMove(from, dst)) return;
            setPath((p) => [...p, dst]);
          }

          function undo() {
            if (path.length > 1) setPath((p) => p.slice(0, -1));
          }
          function resetPath() {
            if (start) setPath([start]);
          }

          // ëª©í‘œ ë‹¬ì„± ì—¬ë¶€
          const reached = useMemo(() => {
            if (!target || !current) return false;
            if (!expert) return current.r === target.r && current.c === target.c;
            const hasMid = mid ? path.some((x) => x.r === mid.r && x.c === mid.c) : true;
            return hasMid && current.r === target.r && current.c === target.c;
          }, [target, current, expert, mid, path]);

          function claimPoint(){
            if (claimed || !reached) return;
            const next = score + 1;
            setScore(next);
            setClaimed(true);
            if (next >= 5) setWin(true);
          }

          // íŒŒ(ìµœë‹¨ ì´ë™ ìˆ˜) ê³„ì‚°
          useEffect(() => {
            if (!start || !target) { setPar(null); setParPath(null); return; }
            const solveSimple = () => bfs(board, start, target);
            const solveExpert = () => {
              if (!mid) return null;
              const p1 = bfs(board, start, mid);
              if (!p1) return null;
              const p2 = bfs(board, mid, target);
              if (!p2) return null;
              return [...p1, ...p2.slice(1)];
            };

            let best = expert ? solveExpert() : solveSimple();
            if (!best) { setPar(null); setParPath(null); return; }
            setPar(best.length - 1);
            setParPath(best);
          }, [board, start, target, expert, mid, reseed]);

          // ìŠ¤íƒ€ì¼ í•¨ìˆ˜ â€” ì˜ìƒ ëŠë‚Œìœ¼ë¡œ í…Œë‘ë¦¬ ìƒ‰, ë‚´ë¶€ëŠ” ì–´ë‘ìš´ ì¹© + LED
          function cellStyle(c) {
            const borderCol = COLOR_HEX[c.color];
            const isStart = !!start && c.r === start.r && c.c === start.c;
            const isTarget = !!target && c.r === target.r && c.c === target.c;
            const isMid = !!mid && c.r === mid.r && c.c === mid.c;
            const isCurrent = !!current && c.r === current.r && c.c === current.c;
            return {
              background: "#0b0f14",
              color: "#e5e7eb",
              borderRadius: 10,
              padding: 4,
              border: `2px solid ${borderCol}`,
              outline: isCurrent ? `3px solid #fff` : isTarget ? `2px dashed #fff` : isStart ? `2px solid #fff` : isMid ? `2px dotted #fff` : undefined,
              cursor: canMove(current ?? start, c) ? "pointer" : "default",
              userSelect: "none",
              boxShadow: `inset 0 0 0 2px rgba(0,0,0,0.6), 0 2px 8px rgba(0,0,0,0.3)`,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              position: "relative",
              aspectRatio: "1 / 1",
            };
          }

          function Legend() {
            return (
              <div className="flex flex-wrap gap-2 text-xs items-center">
                {COLOR_NAMES.map((c) => (
                  <div key={c} className="flex items-center gap-1">
                    <span style={{ width: 16, height: 16, background: COLOR_HEX[c], display: "inline-block", borderRadius: 4, border: "1px solid rgba(0,0,0,0.2)" }} />
                    <span>{KOREAN_LABELS[c]}({c})</span>
                  </div>
                ))}
              </div>
            );
          }

          function Header() {
            return (
              <div className="flex items-start justify-between gap-4">
                <div className="flex flex-col gap-2">
                  <h1 className="text-2xl font-bold">ë§ˆì´í¬ë¡œ ë¡œë´‡ â€” ì›¹ ë²„ì „</h1>
                  <p className="text-sm text-gray-300">ê·œì¹™: ê°™ì€ <b>ìˆ«ì</b> ë˜ëŠ” ê°™ì€ <b>ìƒ‰</b>ì¸ ì¹¸ìœ¼ë¡œë§Œ ìƒí•˜ì¢Œìš°ë¡œ ì´ë™í•©ë‹ˆë‹¤. (ê°€ê¹Œìš´ ì¹¸ì¼ í•„ìš” ì—†ìŒ)</p>
                  <Legend />
                </div>
                <HUD />
              </div>
            );
          }

          function Controls() {
            const sLab = start ? `${start.num} / ${KOREAN_LABELS[start.color]}` : "â€”";
            const tLab = target ? `${target.num} / ${KOREAN_LABELS[target.color]}` : "â€”";
            const mLab = mid ? `${mid.num} / ${KOREAN_LABELS[mid.color]}` : "â€”";
            return (
              <div className="flex flex-wrap items-center gap-3 mt-3">
                <button className="px-3 py-2 rounded-2xl bg-black text-white" onClick={newRound}>ìƒˆ ë¼ìš´ë“œ</button>
                <button className="px-3 py-2 rounded-2xl bg-gray-800 text-white" onClick={reshuffleBoard}>ë³´ë“œ ì„ê¸°</button>
                <label className="flex items-center gap-2 text-sm">
                  <input type="checkbox" checked={expert} onChange={(e)=>{setExpert(e.target.checked); setMid(null);}} /> ì „ë¬¸ê°€ ëª¨ë“œ(ì¤‘ê°„ ëª©í‘œ í¬í•¨)
                </label>
                <label className="flex items-center gap-2 text-sm">
                  <input type="checkbox" checked={showLabels} onChange={(e)=>setShowLabels(e.target.checked)} /> ë¼ë²¨ í‘œì‹œ
                </label>
                <div className="text-sm">ì‹œì‘: <b>{sLab}</b> / ëª©í‘œ: <b>{tLab}</b> {expert && <>/ ì¤‘ê°„: <b>{mLab}</b></>}</div>
                <div className="text-sm">ì´ë™ ìˆ˜: <b>{Math.max(0, path.length - 1)}</b>{par!==null && <span> / ìµœë‹¨: <b>{par}</b></span>}</div>
                <button className="px-3 py-2 rounded-xl bg-gray-200 text-black" onClick={undo} disabled={path.length<=1}>ë˜ëŒë¦¬ê¸°</button>
                <button className="px-3 py-2 rounded-xl bg-gray-200 text-black" onClick={resetPath} disabled={!start}>ë‹¤ì‹œ</button>
                {parPath && <button className="px-3 py-2 rounded-xl bg-indigo-600 text-white" onClick={()=>setPath(parPath)}>ì •ë‹µ ë³´ê¸°</button>}
              </div>
            );
          }

          function Board() {
            return (
              <div className="grid grid-cols-6 gap-2 select-none bg-[#0a0d12] p-3 rounded-xl shadow-inner">
                {board.map((row, r) => row.map((cell, c) => {
                  const isCurrent = !!current && cell.r===current.r && cell.c===current.c;
                  const isTarget = !!target && cell.r===target.r && cell.c===target.c;
                  return (
                    <div key={cellKey(r,c)} style={cellStyle(cell)} onClick={() => onCellClick(cell)} aria-label={`${cell.num} ${cell.color}`} title={`${cell.num} / ${KOREAN_LABELS[cell.color]}`} className="aspect-square">
                      <PipTile num={cell.num} color={cell.color} />
                      {isCurrent && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                          <PawnGlass size={34} />
                        </div>
                      )}
                      {isTarget && (
                        <div className="absolute top-1 left-1">
                          <Coin filled size={18} />
                        </div>
                      )}
                      {showLabels && (
                        <div className="absolute bottom-1 right-1 text-[10px] bg-black/50 px-1 py-[2px] rounded text-white font-semibold">
                          {cell.num} {KOREAN_LABELS[cell.color]}
                        </div>
                      )}
                    </div>
                  );
                }))}
              </div>
            );
          }

          function Footer() {
            return (
              <div className="text-xs text-gray-400 mt-3">
                <p>í‘œì‹œ â€” êµµì€ ì‹¤ì„ : í˜„ì¬, ì ì„ : ì‹œì‘, íŒŒì„ : ëª©í‘œ, ì ì„ ì : ì¤‘ê°„ ëª©í‘œ</p>
                <p>ìµœë‹¨ê²½ë¡œëŠ” BFS. ë¼ìš´ë“œ ìŠ¹ì ì¹©ì„ íšë“í•˜ë©´ HUD ì ìˆ˜ê°€ +1 ë˜ê³  5ì ì— ë„ë‹¬í•˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</p>
              </div>
            );
          }

          function HUD(){
            return (
              <div className="flex flex-col items-end gap-1">
                <div className="text-sm">ìŠ¹ì ì¹©</div>
                <div className="flex items-center gap-1">
                  {Array.from({length:5}).map((_,i)=> <Coin key={i} filled={i<score} />)}
                </div>
                <div className="text-xs text-gray-300">{score} / 5</div>
              </div>
            );
          }

          // ì´ˆê¸° ë¼ìš´ë“œ ìë™ ìƒì„± (ìµœì´ˆ 1íšŒ) + ë³´ë“œ í…ŒìŠ¤íŠ¸ 1íšŒ ìˆ˜í–‰
          useEffect(() => {
            if (!start && !target) newRound();
            runSelfTests(board);
          }, []);

          return (
            <div className="p-4 max-w-5xl mx-auto text-white" style={{background:"#07090d"}}>
              <Header />
              <Controls />
              <div className="mt-4">
                <Board />
              </div>
              {reached && (
                <div className="mt-3 p-3 bg-green-200/20 border border-green-400/50 rounded-xl text-green-200 flex items-center gap-3">
                  <span className="font-semibold">ëª©í‘œ ë„ë‹¬! ì´ë™ {path.length - 1}íšŒ</span>
                  <button className="px-2 py-1 rounded bg-green-500 text-white text-sm" onClick={claimPoint} disabled={claimed}>ìŠ¹ì ì¹© íšë“</button>
                  <button className="px-2 py-1 rounded bg-gray-700 text-white text-sm" onClick={newRound}>ë‹¤ìŒ ë¼ìš´ë“œ</button>
                </div>
              )}
              {win && (
                <div className="mt-3 p-4 bg-yellow-200/20 border border-yellow-400/50 rounded-xl text-yellow-200">
                  <div className="font-bold text-lg mb-2">ğŸ‰ ìŠ¹ë¦¬! 5ì  ë‹¬ì„±</div>
                  <div className="flex gap-2">
                    <button className="px-3 py-2 rounded bg-yellow-500 text-black" onClick={()=>{setScore(0); setWin(false);}}>ì ìˆ˜ ì´ˆê¸°í™”</button>
                    <button className="px-3 py-2 rounded bg-black text-white" onClick={()=>{setScore(0); setWin(false); reshuffleBoard(); newRound();}}>ìƒˆ ê²Œì„</button>
                  </div>
                </div>
              )}
              <Footer />
            </div>
          );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>